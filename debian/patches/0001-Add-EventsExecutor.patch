From: Timon <todo@todo.todo>
Date: Fri, 20 May 2022 22:43:17 +0000
Subject: Add EventsExecutor

---
 CHANGELOG.rst                                      |  9 ++++
 include/rcl/lexer.h                                |  1 +
 include/rcl/timer.h                                | 27 ++++++++++
 package.xml                                        |  2 +-
 src/rcl/lexer.c                                    |  7 +--
 src/rcl/lexer_lookahead.c                          |  6 +++
 src/rcl/timer.c                                    | 10 ++++
 test/rcl/test_lexer.cpp                            |  3 +-
 test/rcl/test_lexer_lookahead.cpp                  | 45 ++++++++++++++++
 .../test_subscription_content_filter_options.cpp   | 60 +++++++++++-----------
 10 files changed, 134 insertions(+), 36 deletions(-)

diff --git a/CHANGELOG.rst b/CHANGELOG.rst
index 7921303..53b8058 100644
--- a/CHANGELOG.rst
+++ b/CHANGELOG.rst
@@ -2,6 +2,15 @@
 Changelog for package rcl
 ^^^^^^^^^^^^^^^^^^^^^^^^^
 
+5.4.0 (2022-04-29)
+------------------
+
+5.3.1 (2022-04-26)
+------------------
+* Fix buffer overflow in argument parsing caused by lexer returning length beyond length of string (`#979 <https://github.com/ros2/rcl/issues/979>`_)
+* Fix leak in test_subscription_content_filter_options.cpp (`#978 <https://github.com/ros2/rcl/issues/978>`_)
+* Contributors: Shane Loretz
+
 5.3.0 (2022-04-05)
 ------------------
 * add content-filtered-topic interfaces (`#894 <https://github.com/ros2/rcl/issues/894>`_)
diff --git a/include/rcl/lexer.h b/include/rcl/lexer.h
index 7cf3dac..5c41ad1 100644
--- a/include/rcl/lexer.h
+++ b/include/rcl/lexer.h
@@ -88,6 +88,7 @@ typedef enum rcl_lexeme_e
  * This function analyzes a string to see if it starts with a valid lexeme.
  * If the string does not begin with a valid lexeme then lexeme will be RCL_LEXEME_NONE, and the
  * length will be set to include the character that made it impossible.
+ * It will never be longer than the length of the string.
  * If the first character is '\0' then lexeme will be RCL_LEXEME_EOF.
  *
  * <hr>
diff --git a/include/rcl/timer.h b/include/rcl/timer.h
index ec08acf..1432324 100644
--- a/include/rcl/timer.h
+++ b/include/rcl/timer.h
@@ -325,6 +325,33 @@ RCL_WARN_UNUSED
 rcl_ret_t
 rcl_timer_get_time_until_next_call(const rcl_timer_t * timer, int64_t * time_until_next_call);
 
+/// Retrieve the time point value for the next timer call.
+/**
+ * This function will populate the data of the time_point_value object with the
+ * value corresponding to when the next timer call should happen.
+ *
+ * The `time_point_value` argument must point to an allocated rcl_time_point_value_t, as
+ * the time point is copied into that instance.
+ *
+ * <hr>
+ * Attribute          | Adherence
+ * ------------------ | -------------
+ * Allocates Memory   | No
+ * Thread-Safe        | Yes
+ * Uses Atomics       | Yes
+ * Lock-Free          | Yes [1]
+ * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
+ *
+ * \param[in] timer the handle to the timer that is being queried
+ * \param[out] time_point_value the output variable for the result
+ * \return #RCL_RET_OK if the timer until next call was successfully calculated, or
+ * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
+ */
+RCL_PUBLIC
+RCL_WARN_UNUSED
+rcl_ret_t
+rcl_timer_get_next_call_time(const rcl_timer_t * timer, rcl_time_point_value_t * time_point_value);
+
 /// Retrieve the time since the previous call to rcl_timer_call() occurred.
 /**
  * This function calculates the time since the last call and copies it into
diff --git a/package.xml b/package.xml
index fba9b9b..03df870 100644
--- a/package.xml
+++ b/package.xml
@@ -2,7 +2,7 @@
 <?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
 <package format="3">
   <name>rcl</name>
-  <version>5.3.0</version>
+  <version>5.4.0</version>
   <description>The ROS client library common implementation.
     This package contains an API which builds on the ROS middleware API and is optionally built upon by the other ROS client libraries.
   </description>
diff --git a/src/rcl/lexer.c b/src/rcl/lexer.c
index b537548..635573e 100644
--- a/src/rcl/lexer.c
+++ b/src/rcl/lexer.c
@@ -650,10 +650,11 @@ rcl_lexer_analyze(
       movement = state->else_movement;
     }
 
-    // Move the lexer to another character in the string
     if (0u == movement) {
-      // Go forwards 1 char
-      ++(*length);
+      if ('\0' != current_char) {
+        // Go forwards 1 char as long as the end hasn't been reached
+        ++(*length);
+      }
     } else {
       // Go backwards N chars
       if (movement - 1u > *length) {
diff --git a/src/rcl/lexer_lookahead.c b/src/rcl/lexer_lookahead.c
index c0fb0af..c72d847 100644
--- a/src/rcl/lexer_lookahead.c
+++ b/src/rcl/lexer_lookahead.c
@@ -141,6 +141,12 @@ rcl_lexer_lookahead2_peek2(
   }
   RCL_CHECK_ARGUMENT_FOR_NULL(next_type2, RCL_RET_INVALID_ARGUMENT);
 
+  if (RCL_LEXEME_NONE == *next_type1 || RCL_LEXEME_EOF == *next_type1) {
+    // No need to peek further
+    *next_type2 = *next_type1;
+    return ret;
+  }
+
   size_t length;
 
   if (buffer->impl->text_idx >= buffer->impl->end[1]) {
diff --git a/src/rcl/timer.c b/src/rcl/timer.c
index 77239fb..98da2d0 100644
--- a/src/rcl/timer.c
+++ b/src/rcl/timer.c
@@ -328,6 +328,16 @@ rcl_timer_get_time_until_next_call(const rcl_timer_t * timer, int64_t * time_unt
   return RCL_RET_OK;
 }
 
+rcl_ret_t
+rcl_timer_get_next_call_time(const rcl_timer_t * timer, rcl_time_point_value_t * time_point_value)
+{
+  RCL_CHECK_ARGUMENT_FOR_NULL(timer, RCL_RET_INVALID_ARGUMENT);
+  RCL_CHECK_ARGUMENT_FOR_NULL(time_point_value, RCL_RET_INVALID_ARGUMENT);
+
+  *time_point_value = rcutils_atomic_load_int64_t(&timer->impl->next_call_time);
+  return RCL_RET_OK;
+}
+
 rcl_ret_t
 rcl_timer_get_time_since_last_call(
   const rcl_timer_t * timer,
diff --git a/test/rcl/test_lexer.cpp b/test/rcl/test_lexer.cpp
index ee2dc1f..d231a68 100644
--- a/test/rcl/test_lexer.cpp
+++ b/test/rcl/test_lexer.cpp
@@ -45,7 +45,8 @@ public:
     rcl_ret_t ret = rcl_lexer_analyze(text, &actual_lexeme, &length); \
     ASSERT_EQ(RCL_RET_OK, ret); \
     EXPECT_EQ(expected_lexeme, actual_lexeme); \
-    std::string actual_text(text, length); \
+    std::string actual_text(text, 0u, length); \
+    EXPECT_EQ(length, actual_text.size()); \
     EXPECT_STREQ(expected_text, actual_text.c_str()); \
   } while (false)
 
diff --git a/test/rcl/test_lexer_lookahead.cpp b/test/rcl/test_lexer_lookahead.cpp
index d6dd181..c2b1bd5 100644
--- a/test/rcl/test_lexer_lookahead.cpp
+++ b/test/rcl/test_lexer_lookahead.cpp
@@ -118,6 +118,51 @@ TEST_F(CLASSNAME(TestLexerLookaheadFixture, RMW_IMPLEMENTATION), test_peek2)
   EXPECT_EQ(RCL_LEXEME_FORWARD_SLASH, lexeme2);
 }
 
+TEST_F(CLASSNAME(TestLexerLookaheadFixture, RMW_IMPLEMENTATION), test_peek2_no_lexeme)
+{
+  rcl_ret_t ret;
+  rcl_lexer_lookahead2_t buffer;
+  SCOPE_LOOKAHEAD2(buffer, "~foo");
+
+  rcl_lexeme_t lexeme1 = RCL_LEXEME_NONE;
+  rcl_lexeme_t lexeme2 = RCL_LEXEME_NONE;
+
+  ret = rcl_lexer_lookahead2_peek2(&buffer, &lexeme1, &lexeme2);
+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;
+  EXPECT_EQ(RCL_LEXEME_NONE, lexeme1);
+  EXPECT_EQ(RCL_LEXEME_NONE, lexeme2);
+}
+
+TEST_F(CLASSNAME(TestLexerLookaheadFixture, RMW_IMPLEMENTATION), test_peek2_no_lexeme_eof)
+{
+  rcl_ret_t ret;
+  rcl_lexer_lookahead2_t buffer;
+  SCOPE_LOOKAHEAD2(buffer, "~");
+
+  rcl_lexeme_t lexeme1 = RCL_LEXEME_NONE;
+  rcl_lexeme_t lexeme2 = RCL_LEXEME_NONE;
+
+  ret = rcl_lexer_lookahead2_peek2(&buffer, &lexeme1, &lexeme2);
+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;
+  EXPECT_EQ(RCL_LEXEME_NONE, lexeme1);
+  EXPECT_EQ(RCL_LEXEME_NONE, lexeme2);
+}
+
+TEST_F(CLASSNAME(TestLexerLookaheadFixture, RMW_IMPLEMENTATION), test_peek2_eof)
+{
+  rcl_ret_t ret;
+  rcl_lexer_lookahead2_t buffer;
+  SCOPE_LOOKAHEAD2(buffer, "");
+
+  rcl_lexeme_t lexeme1 = RCL_LEXEME_NONE;
+  rcl_lexeme_t lexeme2 = RCL_LEXEME_NONE;
+
+  ret = rcl_lexer_lookahead2_peek2(&buffer, &lexeme1, &lexeme2);
+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;
+  EXPECT_EQ(RCL_LEXEME_EOF, lexeme1);
+  EXPECT_EQ(RCL_LEXEME_EOF, lexeme2);
+}
+
 TEST_F(CLASSNAME(TestLexerLookaheadFixture, RMW_IMPLEMENTATION), test_eof)
 {
   rcl_ret_t ret;
diff --git a/test/rcl/test_subscription_content_filter_options.cpp b/test/rcl/test_subscription_content_filter_options.cpp
index 163bf3d..ce19164 100644
--- a/test/rcl/test_subscription_content_filter_options.cpp
+++ b/test/rcl/test_subscription_content_filter_options.cpp
@@ -115,9 +115,9 @@ TEST(TestSubscriptionOptionsContentFilter, subscription_options_success)
 class TestSubscriptionContentFilterOptions : public ::testing::Test
 {
 public:
-  rcl_context_t * context_ptr;
-  rcl_node_t * node_ptr;
-  rcl_subscription_t * subscription_ptr;
+  std::unique_ptr<rcl_context_t> context_;
+  std::unique_ptr<rcl_node_t> node_;
+  std::unique_ptr<rcl_subscription_t> subscription_;
   void SetUp()
   {
     rcl_ret_t ret;
@@ -129,41 +129,39 @@ public:
       {
         EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(&init_options)) << rcl_get_error_string().str;
       });
-      this->context_ptr = new rcl_context_t;
-      *this->context_ptr = rcl_get_zero_initialized_context();
-      ret = rcl_init(0, nullptr, &init_options, this->context_ptr);
+      context_ = std::make_unique<rcl_context_t>();
+      *context_ = rcl_get_zero_initialized_context();
+      ret = rcl_init(0, nullptr, &init_options, &*context_);
       ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;
     }
-    this->node_ptr = new rcl_node_t;
-    *this->node_ptr = rcl_get_zero_initialized_node();
+    node_ = std::make_unique<rcl_node_t>();
+    *node_ = rcl_get_zero_initialized_node();
     constexpr char name[] = "test_subscription_content_filter_options_node";
     rcl_node_options_t node_options = rcl_node_get_default_options();
-    ret = rcl_node_init(this->node_ptr, name, "", this->context_ptr, &node_options);
+    ret = rcl_node_init(&*node_, name, "", &*context_, &node_options);
     ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;
 
     const rosidl_message_type_support_t * ts =
       ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes);
     constexpr char topic[] = "chatter";
 
-    this->subscription_ptr = new rcl_subscription_t;
-    *this->subscription_ptr = rcl_get_zero_initialized_subscription();
+    subscription_ = std::make_unique<rcl_subscription_t>();
+    *subscription_ = rcl_get_zero_initialized_subscription();
     rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();
     ret = rcl_subscription_init(
-      this->subscription_ptr, this->node_ptr, ts, topic, &subscription_options);
+      &*subscription_, &*node_, ts, topic, &subscription_options);
     ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;
   }
 
   void TearDown()
   {
-    rcl_ret_t ret = rcl_subscription_fini(this->subscription_ptr, this->node_ptr);
+    rcl_ret_t ret = rcl_subscription_fini(&*subscription_, &*node_);
     EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;
-    ret = rcl_node_fini(this->node_ptr);
-    delete this->node_ptr;
+    ret = rcl_node_fini(&*node_);
     EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;
-    ret = rcl_shutdown(this->context_ptr);
+    ret = rcl_shutdown(&*context_);
     EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;
-    ret = rcl_context_fini(this->context_ptr);
-    delete this->context_ptr;
+    ret = rcl_context_fini(&*context_);
     EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;
   }
 };
@@ -183,21 +181,21 @@ TEST_F(TestSubscriptionContentFilterOptions, content_filter_options_failure) {
   EXPECT_EQ(
     RCL_RET_INVALID_ARGUMENT,
     rcl_subscription_content_filter_options_init(
-      this->subscription_ptr, nullptr, 0, nullptr, nullptr)
+      &*subscription_, nullptr, 0, nullptr, nullptr)
   );
   rcl_reset_error();
 
   EXPECT_EQ(
     RCL_RET_INVALID_ARGUMENT,
     rcl_subscription_content_filter_options_init(
-      this->subscription_ptr, filter_expression1, 0, nullptr, nullptr)
+      &*subscription_, filter_expression1, 0, nullptr, nullptr)
   );
   rcl_reset_error();
 
   EXPECT_EQ(
     RCL_RET_INVALID_ARGUMENT,
     rcl_subscription_content_filter_options_init(
-      this->subscription_ptr, filter_expression1, 1, nullptr, &content_filter_options)
+      &*subscription_, filter_expression1, 1, nullptr, &content_filter_options)
   );
   rcl_reset_error();
 
@@ -212,21 +210,21 @@ TEST_F(TestSubscriptionContentFilterOptions, content_filter_options_failure) {
   EXPECT_EQ(
     RCL_RET_INVALID_ARGUMENT,
     rcl_subscription_content_filter_options_set(
-      this->subscription_ptr, nullptr, 0, nullptr, nullptr)
+      &*subscription_, nullptr, 0, nullptr, nullptr)
   );
   rcl_reset_error();
 
   EXPECT_EQ(
     RCL_RET_INVALID_ARGUMENT,
     rcl_subscription_content_filter_options_set(
-      this->subscription_ptr, filter_expression1, 0, nullptr, nullptr)
+      &*subscription_, filter_expression1, 0, nullptr, nullptr)
   );
   rcl_reset_error();
 
   EXPECT_EQ(
     RCL_RET_INVALID_ARGUMENT,
     rcl_subscription_content_filter_options_set(
-      this->subscription_ptr, filter_expression1, 1, nullptr, &content_filter_options)
+      &*subscription_, filter_expression1, 1, nullptr, &content_filter_options)
   );
   rcl_reset_error();
 
@@ -240,7 +238,7 @@ TEST_F(TestSubscriptionContentFilterOptions, content_filter_options_failure) {
   EXPECT_EQ(
     RCL_RET_INVALID_ARGUMENT,
     rcl_subscription_content_filter_options_fini(
-      this->subscription_ptr, nullptr)
+      &*subscription_, nullptr)
   );
   rcl_reset_error();
 }
@@ -258,7 +256,7 @@ TEST_F(TestSubscriptionContentFilterOptions, content_filter_options_success)
     EXPECT_EQ(
       RCL_RET_OK,
       rcl_subscription_content_filter_options_init(
-        this->subscription_ptr, filter_expression1, 0, nullptr,
+        &*subscription_, filter_expression1, 0, nullptr,
         &subscription_content_filter_options)
     );
 
@@ -272,7 +270,7 @@ TEST_F(TestSubscriptionContentFilterOptions, content_filter_options_success)
     EXPECT_EQ(
       RCL_RET_OK,
       rcl_subscription_content_filter_options_set(
-        this->subscription_ptr, filter_expression1_update, 0, nullptr,
+        &*subscription_, filter_expression1_update, 0, nullptr,
         &subscription_content_filter_options)
     );
 
@@ -302,7 +300,7 @@ TEST_F(TestSubscriptionContentFilterOptions, content_filter_options_success)
     EXPECT_EQ(
       RCL_RET_OK,
       rcl_subscription_content_filter_options_init(
-        this->subscription_ptr, filter_expression2, expression_parameters_count2,
+        &*subscription_, filter_expression2, expression_parameters_count2,
         expression_parameters2, &subscription_content_filter_options2)
     );
 
@@ -323,7 +321,7 @@ TEST_F(TestSubscriptionContentFilterOptions, content_filter_options_success)
     EXPECT_EQ(
       RCL_RET_OK,
       rcl_subscription_content_filter_options_set(
-        this->subscription_ptr, filter_expression2_update, expression_parameters_count2_update,
+        &*subscription_, filter_expression2_update, expression_parameters_count2_update,
         expression_parameters2_update, &subscription_content_filter_options2)
     );
 
@@ -344,11 +342,11 @@ TEST_F(TestSubscriptionContentFilterOptions, content_filter_options_success)
   EXPECT_EQ(
     RCL_RET_OK,
     rcl_subscription_content_filter_options_fini(
-      this->subscription_ptr, &subscription_content_filter_options)
+      &*subscription_, &subscription_content_filter_options)
   );
   EXPECT_EQ(
     RCL_RET_OK,
     rcl_subscription_content_filter_options_fini(
-      this->subscription_ptr, &subscription_content_filter_options2)
+      &*subscription_, &subscription_content_filter_options2)
   );
 }
